    $$\begin{aligned}
        \Lspline_{PQpq}(t) =& P + pt + (3Q-3P-2p-q)t^2 + (2P-2Q+p+q)t^3 \\
        &\Rightarrow \diffrm\Lspline(0) = p,\phantom{--} \diffrm\Lspline(1) = q \\
    \end{aligned}$$
    The following abbreviation will be useful for readability purposes:
    $$\begin{aligned}
        T :=&\phantom{.} 3Q-3P-2p-q \\
        U :=&\phantom{.} 2P-2Q+p+q \\
    \end{aligned}$$
    diff:
    $$\begin{aligned}
        \diffrm\Lspline_{PQpq}(t) = p + 2Tt + 3Ut^2 \\
    \end{aligned}$$
    subspline:
    The Spline following $\Lspline$ from $t_1$ to $t_2$ can be defined as follows:
    $$\begin{aligned}
        P =&\phantom{.} \Lspline(t_1) & Q =&\phantom{.} \Lspline(t_2) \\
        p =&\phantom{.} (t_2-t_1)\diffrm\Lspline(t_1) & q =&\phantom{.} (t_2-t_1)\diffrm\Lspline(t_2-t_1)(t_2)) \\
    \end{aligned}$$
\subsection{Intersection of Splines}
    % \input{splines_intersection_algebra.tex}
    Finding out, that a Solution for the Intersection $\Lspline_1(t) = \Lspline_2(u)$ is increadibly difficult and generally impossible to find analyically, took a long time and a lot of lines of \LaTeX... When I realized that I could not do it, I went with the unclean, imprecise and much less satisfying approach of putting hairbands on the Splines everywhere and letting them slowly wiggle together. What I'm talking about is Gradient Descent, with a number of parameters $t_i$ along Spline $A$ and the same number of parameters $u_j$ along $B$. Every possible pair of parameters $(t_i, u_j)$ is slowly changed to reduce the distance of the Points $A(t), B(u)$ according to a very simple approximation of the gradient:
    $$\begin{aligned}
        \diff{}t =& \frac{\alpha}{2\varepsilon} \left(\left|A(t-\varepsilon) - B(u)\right| - \left|A(t+\varepsilon) - B(u)\right|\right)\\
        \diff{}u =& \frac{\alpha}{2\varepsilon} \left(\left|A(t) - B(u-\varepsilon)\right| - \left|A(t) - B(u+\varepsilon)\right|\right) \\
    \end{aligned}$$
    Here, $\alpha$ is the speed of the approximation, and there must be a hundred ways to make the convergence more efficient. Additional measures that are used in the algorithm:
    \begin{itemize}
        \item Accepting pairs, where the distance of the points is less than {\tt done\_crit} (default: 0.005), as solutions and removing them from the active pool
        \item Removing pairs, where $t$ or $u$ are outside the Spline's Definition $[0, 1]$
        \item Removing pairs that are almost the same as an accepted solution $(t_2, u_2)$: $|A(t) - A(t_2)| < $\phantom{.}{\tt same\_crit} and $|B(u) - B(u_2)| < $\phantom{.}{\tt same\_crit} (default: {\tt same\_crit} = 0.02)
        \item Removing pairs that are not changing anymore ($|\diff{}t|, |\diff{}u| < $\phantom{.}{\tt fixed\_crit}, default: {\tt fixed\_crit} = 0.0001)
        \item In self-intersection: $A = B$, so $t = u$ is useless and gets removed ($|t - u| < $\phantom{.}{\tt identical\_crit}, default: 0.05)
    \end{itemize}
    Another measure is rather practical: Two Splines that are subsequent – or: neighbors – in the Line, will always have the intersection where they join. That solution is of no value for the actual pupose and is therefore removed, if the corresponding parameter {\tt neighbors = true} is passed. Self-intersection calls also have to be marked in a similar way, with {\tt identical = true}.
